

### COMIENZO DEL PROYECTO ###




--- Archivo: ./src/main/java/org/transporte/serafin/servlets/ParadaLineasServlet.java ---


package org.transporte.serafin.servlets;

import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.sql.*;
import java.util.stream.Collectors;

import org.json.JSONArray;
import org.json.JSONObject;

@WebServlet("/api/paradaLineas")
public class ParadaLineasServlet extends HttpServlet {

    private static final String DB_URL  = "jdbc:postgresql://localhost:5432/transporte";
    private static final String DB_USER = "admin";   // usa las mismas credenciales que en los otros servlets que FUNCIONAN
    private static final String DB_PASS = "admin";

    static {
        try {
            Class.forName("org.postgresql.Driver");
            System.out.println(">>> Driver PostgreSQL cargado en ParadaLineasServlet");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        resp.setContentType("application/json;charset=UTF-8");

        JSONObject json = new JSONObject();

        String paradaIdStr = req.getParameter("paradaId");
        if (paradaIdStr == null) {
            json.put("success", false);
            json.put("error", "Falta par√°metro paradaId");
            resp.getWriter().write(json.toString());
            return;
        }

        int paradaId;
        try {
            paradaId = Integer.parseInt(paradaIdStr);
        } catch (NumberFormatException e) {
            json.put("success", false);
            json.put("error", "paradaId debe ser entero");
            resp.getWriter().write(json.toString());
            return;
        }

        String sql =
            "SELECT pl.linea_id, l.codigo, pl.horarios, pl.habilitada " +
            "FROM parada_linea pl " +
            "JOIN lineas l ON l.id = pl.linea_id " +
            "WHERE pl.parada_id = ? " +
            "ORDER BY l.codigo";

        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS);
             PreparedStatement ps = conn.prepareStatement(sql)) {

            ps.setInt(1, paradaId);

            try (ResultSet rs = ps.executeQuery()) {
                JSONArray arr = new JSONArray();

                while (rs.next()) {
                    JSONObject o = new JSONObject();
                    o.put("linea_id", rs.getInt("linea_id"));
                    o.put("codigo", rs.getString("codigo"));

                    String horariosStr = rs.getString("horarios");
                    if (horariosStr == null || horariosStr.isBlank()) {
                        o.put("horarios", new JSONArray());
                    } else {
                        try {
                            o.put("horarios", new JSONArray(horariosStr));
                        } catch (Exception ex) {
                            // Por si el texto no es JSON v√°lido
                            JSONArray ha = new JSONArray();
                            ha.put(horariosStr);
                            o.put("horarios", ha);
                        }
                    }

                    o.put("habilitada", rs.getBoolean("habilitada"));

                    arr.put(o);
                }

                json.put("success", true);
                json.put("paradaId", paradaId);
                json.put("lineas", arr);
            }

        } catch (Exception e) {
            e.printStackTrace();
            json.put("success", false);
            json.put("error", e.getMessage());
        }

        resp.getWriter().write(json.toString());
    }
}



--- Archivo: ./src/main/java/org/transporte/serafin/servlets/RegistrarLineaServlet.java ---


package org.transporte.serafin.servlets;

import jakarta.servlet.*;
import jakarta.servlet.http.*;
import jakarta.servlet.annotation.*;
import java.io.*;
import java.sql.*;
import org.json.JSONObject;

@WebServlet("/api/registrarLinea")
public class RegistrarLineaServlet extends HttpServlet {

    private static final String DB_URL  = "jdbc:postgresql://localhost:5432/transporte";
    private static final String DB_USER = "admin";
    private static final String DB_PASS = "admin";

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {

        resp.setContentType("application/json; charset=UTF-8");
        JSONObject json = new JSONObject();

        try {
            String codigo   = req.getParameter("codigo");
            String origen   = req.getParameter("origen");
            String destino  = req.getParameter("destino");
            String empresa  = req.getParameter("empresa");
            String geomJson = req.getParameter("geom");

            if (codigo == null || origen == null || destino == null || empresa == null || geomJson == null) {
                json.put("success", false);
                json.put("error", "Faltan par√°metros");
                resp.getWriter().write(json.toString());
                return;
            }

            try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS)) {

                String sql = "SELECT registrar_linea(?, ?, ?, ?, ?::json) AS resultado";

                try (PreparedStatement ps = conn.prepareStatement(sql)) {
                    ps.setString(1, codigo);
                    ps.setString(2, origen);
                    ps.setString(3, destino);
                    ps.setString(4, empresa);
                    ps.setString(5, geomJson);

                    try (ResultSet rs = ps.executeQuery()) {
                        if (rs.next()) {
                            JSONObject resultado = new JSONObject(rs.getString("resultado"));
                            resp.getWriter().write(resultado.toString());
                            return;
                        }
                    }
                }
            }

            json.put("success", false);
            json.put("error", "No se obtuvo respuesta");
            resp.getWriter().write(json.toString());

        } catch (Exception e) {
            e.printStackTrace();
            json.put("success", false);
            json.put("error", e.getMessage());
            resp.getWriter().write(json.toString());
        }
    }
}



--- Archivo: ./src/main/java/org/transporte/serafin/servlets/NuevaRutaConViaServlet.java ---


package org.transporte.serafin.servlets;

import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.ServletException;

import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import org.json.JSONObject;
import org.json.JSONArray;
import org.json.JSONException;

@WebServlet("/api/nuevaRutaConVia")
public class NuevaRutaConViaServlet extends HttpServlet {

    // Usamos la misma config que en NuevaRutaServlet
    private static final String DB_URL  = "jdbc:postgresql://localhost:5432/transporte";
    private static final String DB_USER = "admin";
    private static final String DB_PASS = "admin";

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {

        // --- INICIO DE C√ìDIGO CORS (igual que en NuevaRutaServlet) ---
        resp.setHeader("Access-Control-Allow-Origin", "*");
        resp.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        resp.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");

        if ("OPTIONS".equalsIgnoreCase(req.getMethod())) {
            resp.setStatus(HttpServletResponse.SC_OK);
            return;
        }
        // --- FIN DE C√ìDIGO CORS ---

        resp.setContentType("application/json;charset=UTF-8");
        JSONObject json = new JSONObject();

        // Leer par√°metros
        String idInicioStr = req.getParameter("idInicio");
        String idFinStr    = req.getParameter("idFin");
        String viaLonStr   = req.getParameter("viaLon");
        String viaLatStr   = req.getParameter("viaLat");

        if (idInicioStr == null || idFinStr == null || viaLonStr == null || viaLatStr == null) {
            resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            json.put("success", false);
            json.put("error", "Faltan par√°metros idInicio, idFin, viaLon o viaLat");
            resp.getWriter().write(json.toString());
            return;
        }

        int idInicio, idFin;
        double viaLon, viaLat;

        try {
            idInicio = Integer.parseInt(idInicioStr);
            idFin    = Integer.parseInt(idFinStr);
            viaLon   = Double.parseDouble(viaLonStr);
            viaLat   = Double.parseDouble(viaLatStr);
        } catch (NumberFormatException e) {
            resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            json.put("success", false);
            json.put("error", "Par√°metros num√©ricos inv√°lidos");
            resp.getWriter().write(json.toString());
            return;
        }

        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS)) {

            String sql = "SELECT registrar_ruta_con_via(?, ?, ?, ?) AS resultado";
            try (PreparedStatement ps = conn.prepareStatement(sql)) {
                ps.setInt(1, idInicio);
                ps.setDouble(2, viaLon);
                ps.setDouble(3, viaLat);
                ps.setInt(4, idFin);

                try (ResultSet rs = ps.executeQuery()) {
                    if (rs.next()) {
                        String resultado = rs.getString("resultado");
                        System.out.println(">>> registrar_ruta_con_via devolvi√≥: " + resultado);

                        if (resultado == null || resultado.trim().isEmpty()) {
                            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                            json.put("success", false);
                            json.put("error", "La funci√≥n registrar_ruta_con_via devolvi√≥ NULL o vac√≠o");
                        } else {
                            try {
                                JSONObject obj = new JSONObject(resultado);
                                boolean success = obj.optBoolean("success", false);
                                json.put("success", success);

                                if (success) {
                                    String geomStr = obj.optString("geom", "{}");
                                    try {
                                        JSONObject geom = new JSONObject(geomStr);
                                        json.put("coordinates", geom.optJSONArray("coordinates"));
                                    } catch (JSONException ge) {
                                        System.err.println("Error al parsear geom JSON: " + geomStr);
                                        json.put("coordinates", new JSONArray());
                                    }
                                } else {
                                    json.put("error", obj.optString("message", "Error desconocido"));
                                }

                            } catch (JSONException je) {
                                resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                                json.put("success", false);
                                json.put("error", "JSON inv√°lido devuelto por registrar_ruta_con_via: " + resultado);
                                je.printStackTrace();
                            }
                        }

                    } else {
                        resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                        json.put("success", false);
                        json.put("error", "Sin resultados de la funci√≥n registrar_ruta_con_via");
                    }
                }
            }

        } catch (SQLException e) {
            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            json.put("success", false);
            json.put("error", "Error de base de datos: " + e.getMessage());
            e.printStackTrace();
        }

        resp.getWriter().write(json.toString());
    }
}



--- Archivo: ./src/main/java/org/transporte/serafin/servlets/NuevaRutaServlet.java ---


package org.transporte.serafin.servlets;

import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.ServletException;

import java.io.IOException;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import org.json.JSONObject;
import org.json.JSONArray;
import org.json.JSONException;

@WebServlet("/api/nuevaRuta")
public class NuevaRutaServlet extends HttpServlet {

    private static final String DB_URL = "jdbc:postgresql://localhost:5432/transporte";
    private static final String DB_USER = "admin";
    private static final String DB_PASS = "admin";


    // 2) BLOQUE STATIC PARA CARGAR EL DRIVER JDBC

    static {
        try {
            Class.forName("org.postgresql.Driver");
            System.out.println(">>> Driver PostgreSQL cargado en NuevaRutaServlet");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }


    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {
            
        // --- INICIO DE C√ìDIGO CORS ---
        // 1. Permite solicitudes desde cualquier origen (*) para evitar el error CORS.
        resp.setHeader("Access-Control-Allow-Origin", "*"); 
        
        // 2. Permite los m√©todos que se usar√°n (aunque aqu√≠ solo se use GET)
        resp.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        
        // 3. Permite encabezados espec√≠ficos (Content-Type es crucial)
        resp.setHeader("Access-Control-Allow-Headers", "Content-Type");
        
        // 4. Manejar el pre-flight request de CORS (m√©todo OPTIONS)
        if ("OPTIONS".equalsIgnoreCase(req.getMethod())) {
            resp.setStatus(HttpServletResponse.SC_OK);
            return; // Detiene la ejecuci√≥n para peticiones OPTIONS
        }
        // --- FIN DE C√ìDIGO CORS ---

        resp.setContentType("application/json;charset=UTF-8");
        JSONObject json = new JSONObject();

        String idInicioStr = req.getParameter("idInicio");
        String idFinStr = req.getParameter("idFin");

        if (idInicioStr == null || idFinStr == null) {
            resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            json.put("success", false);
            json.put("error", "Faltan par√°metros idInicio o idFin");
            resp.getWriter().write(json.toString());
            return;
        }

        int idInicio, idFin;
        try {
            idInicio = Integer.parseInt(idInicioStr);
            idFin = Integer.parseInt(idFinStr);
        } catch (NumberFormatException e) {
            resp.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            json.put("success", false);
            json.put("error", "idInicio y idFin deben ser n√∫meros enteros");
            resp.getWriter().write(json.toString());
            return;
     	   }

        try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS)) {

            String sql = "SELECT registrar_ruta(?, ?) AS resultado";
            try (PreparedStatement ps = conn.prepareStatement(sql)) {
                ps.setInt(1, idInicio);
                ps.setInt(2, idFin);

                try (ResultSet rs = ps.executeQuery()) {
                    if (rs.next()) {
                        String resultado = rs.getString("resultado");
                        System.out.println(">>> registrar_ruta devolvi√≥: " + resultado);

                        if (resultado == null || resultado.trim().isEmpty()) {
                            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                            json.put("success", false);
                            json.put("error", "La funci√≥n registrar_ruta devolvi√≥ NULL o vac√≠o");
                        } else {
                            try {
                                JSONObject obj = new JSONObject(resultado);
                                boolean success = obj.optBoolean("success", false);
                                json.put("success", success);

                                if (success) {
                                    String geomStr = obj.optString("geom", "{}");
                                    try {
                                        JSONObject geom = new JSONObject(geomStr);
                                        json.put("coordinates", geom.optJSONArray("coordinates"));
                                    } catch (JSONException ge) {
                                        System.err.println("Error al parsear geom JSON: " + geomStr);
                                        json.put("coordinates", new JSONArray());
                                    }
                                } else {
                                    json.put("error", obj.optString("message", "Error desconocido"));
                                }

                            } catch (JSONException je) {
                                resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                                json.put("success", false);
                                json.put("error", "JSON inv√°lido devuelto por registrar_ruta: " + resultado);
                                je.printStackTrace();
                            }
                        }

                    } else {
                        resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
                        json.put("success", false);
                        json.put("error", "Sin resultados de la funci√≥n registrar_ruta");
                    }
                }
            }

        } catch (SQLException e) {
            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            json.put("success", false);
            json.put("error", "Error de base de datos: " + e.getMessage());
            e.printStackTrace();
        } catch (Exception e) {
            resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            json.put("success", false);
            json.put("error", "Error interno del servidor: " + e.getMessage());
            e.printStackTrace();
        }

        try (PrintWriter out = resp.getWriter()) {
            out.print(json.toString());
        }
    }
    
}



--- Archivo: ./src/main/java/org/transporte/serafin/servlets/NuevaParadaServlet.java ---


package org.transporte.serafin.servlets;

import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.*;
import org.json.JSONObject;

// ya esta registrado @WebServlet("/api/nuevaParada/*")
public class NuevaParadaServlet extends HttpServlet {

    private static final String DB_URL = "jdbc:postgresql://localhost:5432/transporte";
    private static final String DB_USER = "admin";
    private static final String DB_PASS = "admin";

    static {
        try {
            Class.forName("org.postgresql.Driver");
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("ERROR: No se encontr√≥ el driver JDBC.", e);
        }
    }

    private void setCorsHeaders(HttpServletResponse resp) {
        resp.setHeader("Access-Control-Allow-Origin", "*");
        resp.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        resp.setHeader("Access-Control-Allow-Headers", "Content-Type");
    }

    @Override
    protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        setCorsHeaders(resp);
        resp.setStatus(HttpServletResponse.SC_NO_CONTENT);
    }

    // ==========================================================
    // POST (Crear nueva parada)
    // ==========================================================
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        setCorsHeaders(resp);
        resp.setContentType("application/json; charset=UTF-8");

        JSONObject out = new JSONObject();

        try {
            String body = req.getReader().lines().reduce("", (a, b) -> a + b);
            JSONObject json = new JSONObject(body);

            String nombre = json.optString("nombre", "Sin nombre");
            double lon = json.getDouble("lon");
            double lat = json.getDouble("lat");

            try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS)) {
                String sql = "INSERT INTO paradas (nombre, geom) VALUES (?, ST_SetSRID(ST_MakePoint(?, ?), 4326))";

                try (PreparedStatement ps = conn.prepareStatement(sql)) {
                    ps.setString(1, nombre);
                    ps.setDouble(2, lon);
                    ps.setDouble(3, lat);
                    ps.executeUpdate();
                }

                out.put("status", "ok");
                out.put("message", "Parada registrada correctamente.");
            }

        } catch (Exception e) {
            e.printStackTrace();
            out.put("status", "error_general");
            out.put("message", e.getMessage());
            resp.setStatus(400);
        }

        resp.getWriter().write(out.toString());
    }

    // ==========================================================
    // DELETE /api/nuevaParada/{id}
    // ==========================================================
    @Override
    protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        setCorsHeaders(resp);
        resp.setContentType("application/json; charset=UTF-8");
        JSONObject out = new JSONObject();

        try {
            String pathInfo = req.getPathInfo(); // /{id}

            if (pathInfo == null || pathInfo.length() <= 1) {
                resp.setStatus(400);
                out.put("status", "error");
                out.put("message", "Falta ID en la URL.");
                resp.getWriter().write(out.toString());
                return;
            }

            long id = Long.parseLong(pathInfo.substring(1));

            try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS)) {
               String sql = "DELETE FROM paradas WHERE id = ?";
                PreparedStatement ps = conn.prepareStatement(sql);
                ps.setLong(1, id);


                int rows = ps.executeUpdate();
                if (rows > 0) {
                    out.put("status", "ok");
                    out.put("message", "Parada eliminada.");
                } else {
                    resp.setStatus(404);
                    out.put("status", "not_found");
                    out.put("message", "No se encontr√≥ la parada.");
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
            resp.setStatus(400);
            out.put("status", "error_general");
            out.put("message", e.getMessage());
        }

        resp.getWriter().write(out.toString());
    }

    // ==========================================================
    // PUT -> actualizar nombre + posici√≥n de una parada
    // ==========================================================
    @Override
    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        setCorsHeaders(resp);
        resp.setContentType("application/json; charset=UTF-8");
        JSONObject out = new JSONObject();

        try {
            String body = req.getReader().lines().reduce("", (a,b)->a+b);
            JSONObject json = new JSONObject(body);

            long id = json.getLong("id");
            String nombre = json.getString("nombre");
            double lon = json.getDouble("lon");
            double lat = json.getDouble("lat");
            
            try (Connection conn = DriverManager.getConnection(DB_URL, DB_USER, DB_PASS)) {
                String sql =
                    "UPDATE paradas " +
                    "SET nombre=?, lon=?, lat=?, geom=ST_SetSRID(ST_MakePoint(?, ?), 4326) " +
                    "WHERE id=?";


                PreparedStatement ps = conn.prepareStatement(sql);
                ps.setString(1, nombre);
                ps.setDouble(2, lon);
                ps.setDouble(3, lat);
                ps.setDouble(4, lon);   // geom x
                ps.setDouble(5, lat);   // geom y
                ps.setLong(6, id);      // where


                int rows = ps.executeUpdate();
                if (rows > 0) {
                    out.put("status", "ok");
                    out.put("message", "Parada actualizada.");
                } else {
                    resp.setStatus(404);
                    out.put("status", "not_found");
                    out.put("message", "No existe la parada.");
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
            resp.setStatus(400);
            out.put("status", "error_general");
            out.put("message", e.getMessage());
        }

        resp.getWriter().write(out.toString());
    }
}


--- Archivo: ./src/main/webapp/main.js ---


// main.js transporte-Seraf√≠n
console.log("main.js cargado correctamente");

// MAPA
const map = new ol.Map({
  target: "map",
  layers: [new ol.layer.Tile({ source: new ol.source.OSM() })],
  view: new ol.View({
    center: ol.proj.fromLonLat([-56.1645, -34.9011]),
    zoom: 13
  })
});

// CONFIG
const GEOSERVER_WFS = "http://localhost:9999/geoserver/transporte/ows";
const NAMESPACE = "transporte";
const LAYER_NAME = "paradas";
const PARADAS_API_BASE = "http://localhost:8080/transporte-1.0/api/nuevaParada";


// FORMATO GEOJSON
const geojsonFormat = new ol.format.GeoJSON();

// FUENTE WFS
const sourceParadas = new ol.source.Vector({
  format: geojsonFormat,
  loader: (extent, resolution, projection, success, failure) => {
    const viewExtent = ol.proj.transformExtent(extent, projection.getCode(), "EPSG:4326");

    const url =
  `${GEOSERVER_WFS}?service=WFS&version=2.0.0&request=GetFeature` +
  `&typeNames=${NAMESPACE}:${LAYER_NAME}` +
  `&outputFormat=application/json&srsName=EPSG:4326` +
  `&bbox=${viewExtent.join(",")},EPSG:4326`;

    fetch(url)
      .then(r => r.json())
      .then(data => {
        const feats = geojsonFormat.readFeatures(data, {
          featureProjection: "EPSG:3857"
        });
        sourceParadas.clear(true);
        sourceParadas.addFeatures(feats);
        success(feats);
      })
      .catch(err => {
        console.error("Error cargando WFS:", err);
        failure();
      });
  },
  strategy: ol.loadingstrategy.bbox
});

// CAPA
const vectorLayerParadas = new ol.layer.Vector({
  source: sourceParadas,
  style: f =>
    new ol.style.Style({
      image: new ol.style.Circle({
        radius: 7,
        fill: new ol.style.Fill({ color: "red" }),
        stroke: new ol.style.Stroke({ color: "#fff", width: 2 })
      })
    })
});
map.addLayer(vectorLayerParadas);
// CAPA PARA RUTAS
const sourceRuta = new ol.source.Vector();
const layerRuta = new ol.layer.Vector({
  source: sourceRuta,
  style: new ol.style.Style({
    stroke: new ol.style.Stroke({
      color: "blue",
      width: 4
    })
  })
});
map.addLayer(layerRuta);

// INTERACCIONES PARA RUTAS (editar geometr√≠a de la l√≠nea)
const selectRuta = new ol.interaction.Select({
  layers: [layerRuta],
  hitTolerance: 6
});

const modifyRuta = new ol.interaction.Modify({
  features: selectRuta.getFeatures()
});

// Al principio desactivadas: se activan s√≥lo cuando el usuario toca el bot√≥n "Modificar ruta"
selectRuta.setActive(false);
modifyRuta.setActive(false);

map.addInteraction(selectRuta);
map.addInteraction(modifyRuta);


// INTERACCIONES
const select = new ol.interaction.Select({ layers: [vectorLayerParadas], hitTolerance: 6 });
const modify = new ol.interaction.Modify({ features: select.getFeatures() });
const translate = new ol.interaction.Translate({ features: select.getFeatures() });
map.addInteraction(select);
map.addInteraction(modify);
map.addInteraction(translate);

// MODOS
let modoParada = false;
let modoEliminar = false;
let modoModificar = false;
let paradaInicio = null;
let paradaFin = null;
let modoModificarRuta = false; 

// ESTADO DE RUTA ACTUAL
let rutaActualLonLat = null;  // array de [lon, lat] de la ruta actual
let rutaIdInicio = null;
let rutaIdFin = null;

// POPUP
const popup = document.getElementById("popup");
const popupContent = document.getElementById("popup-content");
const overlay = new ol.Overlay({
  element: popup,
  autoPan: true,
  positioning: "bottom-center",
  offset: [0, -10]
});
map.addOverlay(overlay);

// UI
document.getElementById("btnCrearParada").onclick = () => {
  modoParada = true;
  modoEliminar = modoModificar = false;
  alert("Modo CREAR: clic en el mapa para agregar una parada.");
};

document.getElementById("btnModoEliminar").onclick = () => {
  modoEliminar = !modoEliminar;
  modoParada = modoModificar = false;
  alert(modoEliminar ? "Modo ELIMINAR activado" : "Modo ELIMINAR desactivado");
};

document.getElementById("btnRefrescar").onclick = () => {
  sourceParadas.clear();
  sourceParadas.refresh();
};

// Bot√≥n para MODIFICAR RUTA (mover nodos de la l√≠nea ya calculada)
const btnModificarRuta = document.getElementById("btnModificarRuta");
if (btnModificarRuta) {
  btnModificarRuta.onclick = () => {
    if (!rutaActualLonLat || !rutaActualLonLat.length) {
      alert("No hay ninguna ruta dibujada para modificar.");
      return;
    }

    modoModificarRuta = !modoModificarRuta;
    selectRuta.setActive(modoModificarRuta);
    modifyRuta.setActive(modoModificarRuta);

    alert(
      modoModificarRuta
        ? "Modo MODIFICAR RUTA activado: hac√© clic en la l√≠nea y arrastr√° un v√©rtice."
        : "Modo MODIFICAR RUTA desactivado."
    );
  };
}


// HELPERS
function getFeatureId(f) {
  const fid = f.getId();
  if (fid) {
    const parts = fid.split(".");
    const last = parts[parts.length - 1];
    if (!isNaN(last)) return parseInt(last);
  }
  return parseInt(f.get("gid") || f.get("id") || f.get("objectid"));
}

function getFeatureById(id) {
  return sourceParadas.getFeatures().find(f => getFeatureId(f) === id);
}

// API
function crearParadaRemote(lon, lat, nombre) {
  return fetch(PARADAS_API_BASE, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ nombre, lon, lat })
  }).then(r => r.json());
}

function eliminarParadaRemote(id) {
  return fetch(`${PARADAS_API_BASE}/${id}`, { method: "DELETE" }).then(r => r.json());
}

function actualizarParadaRemote(id, nombre, lon, lat) {
  const f = getFeatureById(id);

  if (!f) {
    console.error("Feature no encontrada para id", id);
    return Promise.reject("Feature no encontrada");
  }

  if (nombre === undefined || nombre === null) {
    nombre = f.get("nombre");
  }

  if (lon === undefined || lat === undefined) {
    const coords = ol.proj.toLonLat(f.getGeometry().getCoordinates());
    lon = coords[0];
    lat = coords[1];
  }

  return fetch(`${PARADAS_API_BASE}/${id}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ id, nombre, lon, lat })
  }).then(r => r.json());
}

//handler de eventos

map.on("singleclick", function(evt) {

    // 1) MODO CREAR PARADA
    if (modoParada) {
        const [lon, lat] = ol.proj.toLonLat(evt.coordinate);
        const nombre = prompt("Nombre de la parada:");
        if (!nombre) {
            modoParada = false;
            return;
        }

        crearParadaRemote(lon, lat, nombre)
            .then(r => {
                alert(r.message || "Parada creada");
                sourceParadas.refresh();
            })
            .catch(err => {
                console.error(err);
                alert("Error creando parada");
            });

        modoParada = false;
        return;
    }

    // 2) DETECTAR FEATURE CLICKEADA
    const f = map.forEachFeatureAtPixel(
        evt.pixel,
        (ft, layer) => (layer === vectorLayerParadas ? ft : null)
    );

    // Si el click NO es sobre una parada:
    if (!f) {
        popup.style.display = "none";
        overlay.setPosition(undefined);
        return;
    }

    // <-- AQU√ç definimos el id correctamente
    const paradaId = getFeatureId(f);
    const nombre = f.get("nombre") || "";

    // 3) MODO ELIMINAR
    if (modoEliminar) {
        if (!confirm("¬øEliminar parada " + paradaId + "?")) {
            modoEliminar = false;
            return;
        }

        eliminarParadaRemote(paradaId).then(r => {
            alert(r.message || "Eliminada");
            sourceParadas.refresh();
        }).catch(err => {
            console.error("Error eliminando:", err);
            alert("Error eliminando parada");
        }).finally(() => {
            modoEliminar = false;
        });

        return;
    }

    // 4) SELECCI√ìN DE RUTA (solo si NO estamos en modo modificar)
    if (!modoModificar) {
        if (!paradaInicio) {
            paradaInicio = f;
            alert("Parada de inicio seleccionada: " + paradaId);
            return;
        } else if (!paradaFin) {
            paradaFin = f;
            alert("Parada de fin seleccionada: " + paradaId);
            return;
        }
    }

    // 5) MOSTRAR POPUP (editar / eliminar)
    const coord = f.getGeometry().getCoordinates();

    popupContent.innerHTML = `
        <div><strong>${nombre}</strong></div>
        <div>ID: ${paradaId}</div>

        <div id="popupLineas" style="margin-top:8px; font-size:12px; color:#333;">
            <em>Cargando l√≠neas asociadas...</em>
        </div>

        <div style="margin-top:8px;">
            <button id="popupEditar">Editar</button>
            <button id="popupEliminar2">Eliminar</button>
        </div>
   `;


    overlay.setPosition(coord);
    popup.style.display = "block";

    setTimeout(() => {
        // BOT√ìN EDITAR
        document.getElementById("popupEditar").onclick = () => {
            const nuevo = prompt("Nuevo nombre:", nombre);
            if (nuevo === null) return;

            actualizarParadaRemote(paradaId, nuevo)
                .then(r => {
                    alert(r.message || "Actualizado");
                    popup.style.display = "none";
                    sourceParadas.refresh();
                })
                .catch(err => {
                    console.error("Error actualizando:", err);
                    alert("Error actualizando parada");
                });
        };

        // BOT√ìN ELIMINAR
        document.getElementById("popupEliminar2").onclick = () => {
            if (!confirm("¬øEliminar parada " + paradaId + "?")) return;

            eliminarParadaRemote(paradaId).then(r => {
                alert(r.message || "Eliminada");
                popup.style.display = "none";
                sourceParadas.refresh();
            }).catch(err => {
                console.error("Error eliminando desde popup:", err);    
                alert("Error eliminando parada");
            });
        };

        // üîπ NUEVO: CONTENEDOR PARA MOSTRAR L√çNEAS
        const divLineas = document.createElement("div");
        divLineas.id = "popupLineas";
        divLineas.style.marginTop = "8px";
        divLineas.innerHTML = "<em>Cargando l√≠neas asociadas...</em>";
        popupContent.appendChild(divLineas);
    
        // üîπ NUEVO: Fetch a /api/paradaLineas
        fetch(`http://localhost:8080/transporte-1.0/api/paradaLineas?paradaId=${paradaId}`)
            .then(r => r.json())
            .then(data => {
                console.log("paradaLineas:", data);
    
                if (!data.success) {
                    divLineas.innerHTML = `<span style="color:red;">Error: ${data.error || "No se pudieron cargar las l√≠neas"}</span>`;
                    return;
                }

                const lineas = data.lineas || [];

                if (lineas.length === 0) {
                    divLineas.innerHTML = `<em>No hay l√≠neas asociadas a esta parada.</em>`;
                    return;
                }

                let html = "<u>L√≠neas que pasan por aqu√≠:</u><br>";
                lineas.forEach(l => {
                const horarios = (l.horarios || []).join(", ");
                const estado = l.habilitada ? "habilitada" : "deshabilitada";

                html += `‚Ä¢ ${l.codigo} <small>(${estado})</small>`;
                if (horarios) {
                    html += `<br>&nbsp;&nbsp;Horarios: ${horarios}`;
                }
                html += "<br>";
            });

            divLineas.innerHTML = html;
        })
        .catch(err => {
            console.error("Error cargando l√≠neas de parada:", err);
            divLineas.innerHTML = `<span style="color:red;">Error cargando l√≠neas.</span>`;
        });

    }, 10);

});



// MANEJAR MODIFICACI√ìN O TRASLADO
function manejarEdicion(ev) {
  const f = ev.features.item(0) || ev.features.getArray()[0];
  const id = getFeatureId(f);
  const [lon, lat] = ol.proj.toLonLat(f.getGeometry().getCoordinates());

  actualizarParadaRemote(id, undefined, lon, lat).then(() => {
    sourceParadas.refresh();
  });
}

translate.on("translateend", manejarEdicion);
modify.on("modifyend", manejarEdicion);

// CARGA INICIAL
sourceParadas.refresh();
// Cuando se termina de modificar la geometr√≠a de la RUTA
modifyRuta.on("modifyend", (evt) => {
  const features = evt.features.getArray();
  if (!features.length) return;

  const geom = features[0].getGeometry();
  if (!(geom instanceof ol.geom.LineString)) {
    console.warn("[modifyRuta] La geometr√≠a no es una LineString.");
    return;
  }

  // Coord en proyecci√≥n del mapa ‚Üí pasamos a lon/lat
  const coords3857 = geom.getCoordinates();
  const coordsLonLat = coords3857.map(c => ol.proj.toLonLat(c));

  if (!rutaActualLonLat || rutaActualLonLat.length !== coordsLonLat.length) {
    // Algo raro: cambi√≥ la cantidad de v√©rtices
    rutaActualLonLat = coordsLonLat;
    console.warn("[modifyRuta] Cambio de cantidad de v√©rtices, se actualiza copia local pero no se recalcula.");
    return;
  }

  // Detectar qu√© v√©rtice se movi√≥
  const EPS = 1e-5;
  let movedIndex = -1;

  for (let i = 0; i < coordsLonLat.length; i++) {
    const [lon0, lat0] = rutaActualLonLat[i];
    const [lon1, lat1] = coordsLonLat[i];
    const d = Math.hypot(lon1 - lon0, lat1 - lat0);
    if (d > EPS) {
      movedIndex = i;
      break;
    }
  }

  if (movedIndex === -1) {
    console.log("[modifyRuta] No se detect√≥ v√©rtice movido.");
    return;
  }

  const [viaLon, viaLat] = coordsLonLat[movedIndex];
  console.log("[modifyRuta] V√©rtice movido en √≠ndice", movedIndex, "a", viaLon, viaLat);

  // Actualizamos la copia local
  rutaActualLonLat = coordsLonLat;

  // Pedir rec√°lculo al backend usando este punto como "via"
  recalcularRutaConVia(viaLon, viaLat);
});



function crearRuta() {
  if (!paradaInicio || !paradaFin) {
    alert("Seleccion√° primero la parada de inicio y luego la de fin.");
    return;
  }

  const idInicio = getFeatureId(paradaInicio);
  const idFin = getFeatureId(paradaFin);

  const url = `http://localhost:8080/transporte-1.0/api/nuevaRuta?idInicio=${idInicio}&idFin=${idFin}`;

  fetch(url)
    .then(r => r.json())
    .then(data => {
      console.log("Ruta recibida:", data);

      if (!data || !data.coordinates) {
        alert("El servidor no devolvi√≥ una ruta v√°lida");
        return;
      }

      // Guardar estado de la ruta actual
      rutaIdInicio = idInicio;
      rutaIdFin = idFin;

      // Aplanar el MultiLineString ‚Üí array de [lon,lat]
      const coords = data.coordinates.flat();
      rutaActualLonLat = coords.map(c => [c[0], c[1]]);

      // Dibujar
      dibujarRuta(rutaActualLonLat);

      alert("Ruta creada exitosamente");

      // Reset de selecci√≥n de paradas (pero NO de rutaIdInicio/Fin)
      paradaInicio = null;
      paradaFin = null;
    })
    .catch(err => {
      console.error(err);
      alert("Error creando ruta.");
    });
}


/**
 * Dibuja la ruta en el mapa.
 * @param {Array<Array<number>>} coordinates - Un array de pares [longitud, latitud].
 */
function dibujarRuta(coordinates) {
    console.log(`[dibujarRuta] Recibidas ${coordinates.length} coordenadas.`);

    if (coordinates.length < 2) {
        console.warn("[dibujarRuta] Se necesitan al menos 2 puntos.");
        return;
    }

    // Log coordenadas crudas
    console.log("[dibujarRuta] Coordenadas crudas:", coordinates);

    // Limpiar rutas anteriores
    sourceRuta.clear();

    // Validaci√≥n de formato
    const coords3857 = [];
    for (let i = 0; i < coordinates.length; i++) {
        const c = coordinates[i];

        if (!Array.isArray(c) || c.length !== 2) {
            console.error(`[dibujarRuta] Coordenada inv√°lida √≠ndice ${i}:`, c);
            return;
        }

        const [lon, lat] = c;

        if (isNaN(lon) || isNaN(lat)) {
            console.error(`[dibujarRuta] Coordenada con NaN √≠ndice ${i}:`, c);
            return;
        }

        if (Math.abs(lon) > 200 || Math.abs(lat) > 100) {
            console.error(`[dibujarRuta] Coordenada fuera de rango √≠ndice ${i}:`, c);
            return;
        }

        const transformed = ol.proj.fromLonLat([lon, lat]);
        coords3857.push(transformed);
    }

    console.log("[dibujarRuta] Coordenadas transformadas:", coords3857);

    const lineString = new ol.geom.LineString(coords3857);

    // CHEQUEAR EXTENT
    const extent = lineString.getExtent();
    console.log("[dibujarRuta] Extent:", extent);

    if (extent[0] === extent[2] && extent[1] === extent[3]) {
        console.error("[dibujarRuta] EXTENT VAC√çO ‚Äî las coordenadas transformadas coinciden.");
        return;
    }

    const feature = new ol.Feature({ geometry: lineString });
    sourceRuta.addFeature(feature);

    map.getView().fit(extent, {
        padding: [50, 50, 50, 50],
        duration: 800
    });

    console.log("[dibujarRuta] Ruta dibujada correctamente.");
}

document.getElementById("btnGuardarLinea").addEventListener("click", guardarLinea);

function guardarLinea() {
    if (!rutaActualLonLat) {
        alert("No hay ruta para guardar.");
        return;
    }

    const geom = {
        type: "LineString",
        coordinates: rutaActualLonLat
    };

    const formData = new URLSearchParams();
    formData.append("codigo", prompt("C√≥digo de la l√≠nea"));
    formData.append("origen", prompt("Origen"));
    formData.append("destino", prompt("Destino"));
    formData.append("empresa", "CUTCSA");
    formData.append("geom", JSON.stringify(geom));

    fetch("/transporte-1.0/api/registrarLinea", {
        method: "POST",
        body: formData
    })
    .then(r => r.json())
    .then(res => {
        console.log(res);
        if (res.success) alert("L√≠nea registrada con ID: " + res.linea_id);
        else alert("Error: " + res.error);
    });
}



function recalcularRutaConVia(viaLon, viaLat) {
  if (rutaIdInicio == null || rutaIdFin == null) {
    console.warn("[recalcularRutaConVia] No hay id de inicio/fin guardados.");
    return;
  }

  const url =
    `http://localhost:8080/transporte-1.0/api/nuevaRutaConVia` +
    `?idInicio=${rutaIdInicio}&idFin=${rutaIdFin}` +
    `&viaLon=${viaLon}&viaLat=${viaLat}`;

  fetch(url)
    .then(r => r.json())
    .then(data => {
      console.log("Ruta recalculada:", data);

      if (!data || !data.coordinates) {
        alert("El servidor no devolvi√≥ una ruta v√°lida al recalcular.");
        return;
      }

      // Aplanar el MultiLineString ‚Üí array de [lon,lat]
      const coords = data.coordinates.flat();
      rutaActualLonLat = coords.map(c => [c[0], c[1]]);

      // Redibujar la ruta con la nueva geometr√≠a "pegada" a las calles
      dibujarRuta(rutaActualLonLat);
      alert("Ruta recalculada con el nuevo punto intermedio.");
    })
    .catch(err => {
      console.error(err);
      alert("Error recalculando la ruta.");
    });
}



--- Archivo: ./src/main/webapp/index.html ---


<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Transporte Seraf√≠n</title>

  <!-- OpenLayers CDN -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.4.0/ol.css">
  <script src="https://cdn.jsdelivr.net/npm/ol@v7.4.0/dist/ol.js"></script>

  <style>
      body { margin: 0; font-family: Arial; }
      #map { width: 100%; height: 90vh; }
      #panel {
        padding: 10px;
        background: #eee;
        display: flex;
        gap: 10px;
        border-bottom: 1px solid #ccc;
      }
      #popup {
        position: absolute;
        background: white;
        padding: 10px;
        border: 1px solid black;
        border-radius: 4px;
        min-width: 150px;
        display: none;
      }
  </style>
</head>
<body>

<div id="panel">
<button type="button" id="btnCrearParada">Crear parada</button>
<button type="button" id="btnModoEliminar">Eliminar</button>
<button type="button" id="btnModoModificar">Modificar</button>
<button id="btnGuardarLinea">Guardar l√≠nea</button>
<button type="button" id="btnRefrescar">Refrescar</button>
<button type="button" onclick="crearRuta()" id="btnCrearRuta">Crear Ruta</button>
<button type="button" id="btnModificarRuta">Modificar ruta</button>


</div>

<div id="map"></div>

<div id="popup">
  <div id="popup-content"></div>
</div>

<script src="main.js"></script>
</body>
</html>


--- Archivo: ./src/main/webapp/styles.css ---


html, body {
  margin: 0;
  height: 100%;
}

#map {
  width: 100%;
  height: 100%;
}

.control-panel {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(255, 255, 255, 0.9);
  padding: 10px;
  border-radius: 8px;
  font-family: sans-serif;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

button {
  margin: 4px;
  padding: 6px 10px;
  border: none;
  background: #1976d2;
  color: white;
  border-radius: 4px;
  cursor: pointer;
}

button:hover {
  background: #0d47a1;
}


--- Archivo: ./src/main/resources/js/paradas.js ---


window.addEventListener("load", () => {
  console.log("Cargando m√≥dulo de paradas...");

  const map = window.map;
  const paradasLayer = window.paradasLayer;

  const popup = document.getElementById("popup");
  const popupContent = document.getElementById("popup-content");

  const overlay = new ol.Overlay({
    element: popup,
    positioning: "bottom-center",
    stopEvent: false,
    offset: [0, -15],
  });
  map.addOverlay(overlay);

  function mostrarPopupBonito(coordinate, nombre, lineas = []) {
    let html = `
      <div class="popup-header">
        <span class="popup-icon">üöå</span>
        <strong>${nombre}</strong><br/>
    `;

    if (lineas.length > 0) {
      html += `<small>L√≠neas: ${lineas.map(l => `${l.codigo} (${l.empresa})`).join(", ")}</small>`;
    } else {
      html += `<small>Sin l√≠neas cercanas</small>`;
    }

    html += "</div>";

    popupContent.innerHTML = html;
    popup.style.display = "block";
    overlay.setPosition(coordinate);
  }


  function ocultarPopup() {
    popup.style.display = "none";
    overlay.setPosition(undefined);
  }

  function agregarParada(coordinate) {
    const nombre = prompt("Ingrese el nombre de la parada:");
    if (!nombre || nombre.trim() === "") return;

    const [lon, lat] = ol.proj.toLonLat(coordinate);

    fetch("http://localhost:8080/transporte/api/paradas", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ nombre, lat, lon }),
    })
      .then((r) => {
        if (r.ok) {
          alert("‚úÖ Parada creada correctamente");
          const params = paradasLayer.getSource().getParams();
          params.t = Date.now();
          paradasLayer.getSource().updateParams(params);

          // Despu√©s de guardar parada exitosamente
          window.modoActual = null;
          window.actualizarBannerModo();

        } else {
          alert("‚ùå Error al crear parada");
        }
      })
      .catch((err) => console.error("Error guardando parada:", err));
  }

  // --- Click en el mapa (solo si el modo es 'parada') ---
  map.on("singleclick", function (evt) {
    if (window.modoActual !== "parada") return; // ignorar si no est√° activo

    const viewResolution = map.getView().getResolution();
    const url = paradasLayer.getSource().getFeatureInfoUrl(
      evt.coordinate,
      viewResolution,
      "EPSG:3857",
      { INFO_FORMAT: "application/json" }
    );

    if (!url) {
      ocultarPopup();
      return;
    }

    fetch(url)
      .then((r) => r.json())
      .then((json) => {
        if (json.features && json.features.length > 0) {
          const props = json.features[0].properties;
          const idParada = props.id || props.objectid;
          const nombre = props.nombre;

          // Obtener info de l√≠neas asociadas desde tu backend
          fetch(`http://localhost:8080/transporte/api/paradas/${idParada}/lineas`)
            .then((r) => (r.ok ? r.json() : []))
            .then((lineas) => mostrarPopupBonito(evt.coordinate, nombre, lineas))
            .catch((err) => {
              console.error("Error cargando l√≠neas:", err);
              mostrarPopupBonito(evt.coordinate, nombre, []);
            });
        } else {
          ocultarPopup();
          agregarParada(evt.coordinate);
        }
      })
      .catch((err) => {
        console.error("Error consultando GeoServer:", err);
        ocultarPopup();
      });
  });

  map.on("pointerdown", ocultarPopup);

  // --- Bot√≥n ---
    function activarAltaParada() {
      window.modoActual = "parada";
      window.actualizarBannerModo(); // üîπ actualiza el banner
      alert("üöå Modo PARADA activado. Haga clic en el mapa para agregar una parada.");
    }

  window.activarAltaParada = activarAltaParada;
});


--- Archivo: ./src/main/resources/js/mapa.js ---


// --- Cargar el mapa ---
window.addEventListener("load", () => {
  console.log("Inicializando mapa...");

  // --- Definir EPSG:32721 (UTM 21S) Antes de cargar el mapa---
  proj4.defs("EPSG:32721", "+proj=utm +zone=21 +south +datum=WGS84 +units=m +no_defs");
  ol.proj.proj4.register(proj4);

  const baseLayer = new ol.layer.Tile({
    source: new ol.source.OSM(),
  });

  const paradasLayer = new ol.layer.Tile({
    source: new ol.source.TileWMS({
      url: "http://localhost:8080/geoserver/transporte/wms",
      params: {
        LAYERS: "transporte:paradas",
        TILED: true,
        VERSION: "1.1.1",
        FORMAT: "image/png",
      },
      serverType: "geoserver",
      crossOrigin: "anonymous",
    }),
  });

  const map = new ol.Map({
    target: "map",
    layers: [baseLayer, paradasLayer],
    view: new ol.View({
      center: ol.proj.fromLonLat([-56.1645, -34.9011]),
      zoom: 13,
    }),
  });

  // --- Exponer globalmente ---
  window.map = map;
  window.paradasLayer = paradasLayer;

  // --- Estado global ---
  window.modoActual = null; // "parada" | "linea" | null

  console.log("Mapa listo");

  // Funci√≥n global para mostrar el modo actual en el banner
  window.actualizarBannerModo = function () {
    const banner = document.getElementById("modo-banner");
    const modo = window.modoActual;

    if (modo === "parada") {
      banner.textContent = "Modo: Parada (clic para agregar)";
    } else if (modo === "linea") {
      banner.textContent = "Modo: L√≠nea (doble clic o Enter para finalizar)";
    } else {
      banner.textContent = "Modo: Libre";
    }
  };
});


--- Archivo: ./src/main/resources/js/lineas.js ---


window.addEventListener("load", () => {
  console.log("Cargando m√≥dulo de l√≠neas...");

  const map = window.map;

  // --- Fuente vectorial y capa ---
  const lineasSource = new ol.source.Vector();

  const lineasLayer = new ol.layer.Vector({
    source: lineasSource,
    style: new ol.style.Style({
      stroke: new ol.style.Stroke({
        color: "#FF0000",
        width: 3,
      }),
    }),
  });

  map.addLayer(lineasLayer);

  // ‚úÖ Funci√≥n local que usa lineasSource correctamente
  async function cargarLineas() {
    try {
      const res = await fetch("http://localhost:8080/transporte/api/lineas");
      const data = await res.json();

      const format = new ol.format.GeoJSON();
      const features = data.map((linea) => {
        const geomObj = JSON.parse(linea.geom);
        const geom = format.readGeometry(geomObj);
        geom.transform("EPSG:32721", "EPSG:3857");

        const f = new ol.Feature({ geometry: geom });
        f.setProperties({
          codigo: linea.codigo,
          origen: linea.origen,
          destino: linea.destino,
          empresa: linea.empresa,
        });
        return f;
      });

      lineasSource.clear();
      lineasSource.addFeatures(features);
      console.log(`‚úÖ ${features.length} l√≠neas cargadas.`);
    } catch (err) {
      console.error("Error cargando l√≠neas:", err);
    }
  }

  // --- Llamada inicial (dentro del load, luego de definir lineasSource)
  cargarLineas();

  // --- Mostrar info al clickear sobre una l√≠nea ---
  map.on("singleclick", (evt) => {
    if (window.modoActual) return; // si estamos agregando, ignorar
    map.forEachFeatureAtPixel(evt.pixel, (feature) => {
      const props = feature.getProperties();
      if (props.codigo) {
        const info = `
          C√≥digo: ${props.codigo}
          Origen: ${props.origen}
          Destino: ${props.destino}
          Empresa: ${props.empresa}
        `;
        alert("üöå L√≠nea\n" + info.replace(/<br>/g, "\n"));
      }
    });
  });

  // --- Modo agregar l√≠nea ---
  const drawLinea = new ol.interaction.Draw({
    source: lineasSource,
    type: "LineString",
  });

  function activarAltaLinea() {
    window.modoActual = "linea";
    window.actualizarBannerModo();
    map.addInteraction(drawLinea);
    alert("‚úèÔ∏è Dibuje la l√≠nea (doble clic o Enter para finalizar).");

    drawLinea.once("drawend", async (evt) => {
      map.removeInteraction(drawLinea);
      window.modoActual = null;
      window.actualizarBannerModo();

      const geom = evt.feature.getGeometry().clone().transform("EPSG:3857", "EPSG:32721");
      const geojson = new ol.format.GeoJSON().writeGeometryObject(geom);

      const lineaData = {
        codigo: prompt("C√≥digo de l√≠nea (ej: 104-este):"),
        origen: prompt("Origen:"),
        destino: prompt("Destino:"),
        empresa: prompt("Empresa:"),
        geom: JSON.stringify(geojson),
      };

      try {
        const r = await fetch("http://localhost:8080/transporte/api/lineas", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(lineaData),
        });

        if (r.ok) {
          alert("‚úÖ L√≠nea creada correctamente");
          cargarLineas(); // recarga el mapa con la nueva l√≠nea
        } else {
          const txt = await r.text();
          console.error("Error:", txt);
          alert("‚ùå Error al crear l√≠nea:\n" + txt);
        }
      } catch (err) {
        console.error("Error guardando l√≠nea:", err);
      }
    });
  }
  function cancelarDibujo() {
    // Si hay una interacci√≥n de dibujo activa, la removemos
    map.removeInteraction(drawLinea);

    // Volvemos a modo libre
    window.modoActual = null;
    window.actualizarBannerModo();

    alert("‚ùå Dibujo cancelado.");
  }

  window.activarAltaLinea = activarAltaLinea;
  window.cancelarDibujo = cancelarDibujo;
});
